#!/usr/bin/env escript
%% coding: latin-1
%%%-------------------------------------------------------------------
%%% @author mwh
%%% @copyright (C) 2017, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 08. 六 2017 9:32
%%%-------------------------------------------------------------------

%% 热更新
-define(ST_GS, 1).
-define(ST_CS, 2).
-define(ST_HTTP, 3).

-define(OP_EXIT, 0).

-define(OP_COMPILE_GS, 1).
-define(OP_START_GS, 11).
-define(OP_DEL_LOG_GS, 111).
-define(OP_PK_GS, 1111).

-define(OP_COMPILE_CS, 2).
-define(OP_START_CS, 22).
-define(OP_DEL_LOG_CS, 222).
-define(OP_PK_CS, 2222).

-define(OP_DEL_LOG_ALL, 9).

-define(OP_REF, 901).
-define(OP_DIALYZER, 902).

-define(OP_TCP, 992).
-define(OP_SET_TERMINAL_COLOR, 999).



main(_) ->
    menu(),
    ok.

menu() ->
    os:cmd("CHCP 65001"),
    {ok, Cwd} = file:get_cwd(),
    os:cmd(io_lib:format('title \"~ts\"',[Cwd])),

    color:info_log(
        "~n##########################################################~n"

        "\t~-10.w编译(gs)~n"
		"\t~-10.w开服(gs)~n"
		"\t~-10.w删除日志(gs)~n"
		"\t~-10.w打包(gs)~n"
        
        "#~n"
        "\t~-10.w编译(cs)~n"
        "\t~-10.w开服(cs)~n"
		"\t~-10.w删除日志(cs)~n"
		"\t~-10.w打包(cs)~n"
		"#~n"
		  
        "\t~-10.w删除日志(all)~n"
    
        "#~n"
  
        "\t~-10.w代码检查(xref)~n"
        "\t~-10.w代码检查(dialyzer)~n"
        "#~n"
		"\t~-10.wtcp测试~n"
        "\t~-10.wwindows控制台支持彩色显示~n"
        "\t~-10.w退出~n"
        "~n##########################################################~n~n",
        [
            ?OP_COMPILE_GS,?OP_START_GS, ?OP_DEL_LOG_GS, ?OP_PK_GS, 
			
			?OP_COMPILE_CS,?OP_START_CS,?OP_DEL_LOG_CS,?OP_PK_CS,

            ?OP_DEL_LOG_ALL, 
    
            ?OP_REF, ?OP_DIALYZER,
			
            ?OP_TCP, ?OP_SET_TERMINAL_COLOR,
            ?OP_EXIT
        ]
    ),
    InputNoStr = io:get_line("Please enter your choice:"),
    [T | _] = string:tokens(string_strip(InputNoStr, "\n"), " "),
    {IT, _} = string:to_integer(T),
    Ret = dispatchInput2(IT),
    wait(Ret),
    menu().

dispatchInput2(?OP_EXIT) ->
    erlang:halt();
dispatchInput2(?OP_REF) ->
    erlang:spawn_monitor(fun() -> os:cmd("start xref.bat") end);
dispatchInput2(?OP_DIALYZER) ->
    erlang:spawn_monitor(fun() -> os:cmd("start dialyzer_tool.bat") end);
dispatchInput2(?OP_DEL_LOG_ALL) ->
    erlang:spawn_monitor(fun() -> os:cmd(" cd ..\\ && del /q /s *.log && del /q /s *.err") end),
    color:warn_log("->delete *.log done!<-~n");
dispatchInput2(?OP_DEL_LOG_GS) ->
    erlang:spawn_monitor(fun() -> os:cmd(" cd ..\\app\\game && del /q /s *.log && del /q /s *.err") end);
dispatchInput2(?OP_DEL_LOG_CS) ->
    erlang:spawn_monitor(fun() -> os:cmd(" cd ..\\app\\center && del /q /s *.log && del /q /s *.err") end);
dispatchInput2(?OP_START_GS) ->
    erlang:spawn_monitor(fun() -> os:cmd("cd  ..\\app\\game\\scripts && start start.bat") end);
dispatchInput2(?OP_START_CS) ->
    erlang:spawn_monitor(fun() -> os:cmd("cd  ..\\app\\center\\scripts && start start.bat") end);
dispatchInput2(?OP_PK_GS) ->
    erlang:spawn_monitor(fun() -> os:cmd("start subcall.bat escript.exe ps_gs.ers") end);
dispatchInput2(?OP_PK_CS) ->
    erlang:spawn_monitor(fun() -> os:cmd("start subcall.bat escript.exe ps_cs.ers") end);
dispatchInput2(?OP_COMPILE_GS) ->
    erlang:spawn_monitor(fun() -> os:cmd("start subcall.bat escript.exe fast_compile.ers 1") end);
dispatchInput2(?OP_COMPILE_CS) ->
    erlang:spawn_monitor(fun() -> os:cmd("start subcall.bat escript.exe fast_compile.ers 2") end);
dispatchInput2(?OP_TCP) ->
     erlang:spawn_monitor(fun() -> os:cmd("start tcp_test.bat") end);
dispatchInput2(?OP_SET_TERMINAL_COLOR) ->
     erlang:spawn_monitor(fun() -> os:cmd("start /WAIT terminal_color.bat") end);	 
dispatchInput2(_) ->
    color:error_log("\t!!! error retry !!!~n~n").

wait({Pid, _rcMRef}) when is_pid(Pid) ->
   %% receive
   %%     {'DOWN', _MRef, _process, _Pid, normal} ->
   %%         ok;
   %%     {'DOWN', _MRef, process, Pid, _Reason} ->
   %%         ok;
   %%     {Pid, _Result} ->
   %%         ok
   %% end,
   timer:sleep(1000),
    ok;
wait(_) -> skip.


string_strip(Str, []) ->
    Str;
string_strip(Str, [CH | L]) ->
    string_strip(string:strip(Str, both, CH), L).
